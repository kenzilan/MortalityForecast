% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/doBackTesting.R
\name{doBackTesting}
\alias{doBackTesting}
\title{Perform In-Sample Testing of Mortality Forecasts Over One Time Period}
\usage{
doBackTesting(data, x, y.fit, y.for, data.in = c("qx", "mx", "dx", "lx"),
  models = c("MRWD", "LC"), level = 95, jumpchoice = c("actual",
  "fit"), verbose = FALSE, ...)
}
\arguments{
\item{data}{A data.frame or a matrix containing mortality data 
with ages \code{x} as row and time \code{y} as column. This object should
contain the data to be used in fitting (traning) and validation process as well.}

\item{x}{Numerical vector indicating the ages in input \code{data}. Optional.
Default: \code{NULL}.}

\item{y.fit}{Years to be considered in fitting.}

\item{y.for}{Years to be forecast.}

\item{data.in}{Specify the type of input \code{data}. Various life table 
indices are accepted: \code{"qx", "mx", "dx", "lx"}.}

\item{models}{Mortality models to be evaluated.}

\item{level}{Significance level of the confidence interval.}

\item{jumpchoice}{Method used for computation of jumpchoice. 
Possibilities: \code{"actual"} (use actual rates from final year) 
and \code{"fit"} (use fitted rates).}

\item{verbose}{A logical value. Set \code{verbose = FALSE} to silent 
the process that take place inside the function and avoid progress messages.}

\item{...}{Arguments to be passed to or from other methods.}
}
\description{
Perform In-Sample Testing of Mortality Forecasts Over One Time Period
}
\examples{

x = 0:98              # Ages
y1 = 1980:2000        # Training period
y2 = 2001:2016        # Validation period
y  = c(y1, y2)
h = max(y2) - max(y1) # Forecasting horizon

D <- HMD_male$dx$GBRTENW[paste(x), paste(y)] # DATA

# Select various mortality models
MM <- c("MRWD", "CoDa", "MEM6")
# Fit & Forecast the models 
B <- doBackTesting(data = D, x = x,
                   y.fit = y1, y.for = y2,
                   data.in = "dx",
                   models = MM)

# Compute accuracy measures
# The measures can be computed for different indicators. Even if it is not 
# impossible to get a diffrent classification and ranking the 
# outcome should be in general the same.
evalAccuracy(B, data.out = "mx")
evalAccuracy(B, data.out = "qx")
evalAccuracy(B, data.out = "dx")

# Rank the model's performance.
A <- evalAccuracy(B, data.out = "ex")
A
R <- doRanking(A)
R

# Visualize the results
plot(B, data.out = "mx", facet = "x")
plot(B, data.out = "mx", facet = "y") 
}
\seealso{
\code{\link{doBBackTesting}}
\code{\link{evalAccuracy.doBackTesting}}
}
