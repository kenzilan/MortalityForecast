

#' Perform Multiple Forecast of Mortality Using Various Models
#' 
#' @param object An object of class \code{MotalityModels} generated by the
#' \code{\link{doMortalityModels}} function.
#' @param h Number of years to be forecast in the future.
#' @param level Significance level of the confidence interval.
#' @param jumpchoice Method used for computation of jumpchoice. 
#'  Possibilities: \code{"actual"} (use actual rates from final year) 
#'  and \code{"fit"} (use fitted rates).
#' @inheritParams doMortalityModels
#' @examples 
#' x  <- 0:100
#' y  <- 1985:1999
#' h  <- 17
#' D  <- MortalityForecast.data$dx[paste(x), paste(y)]
#' MM <- c("MRWD", "LeeCarter", "HyndmanUllah", "CoDa", "MEM6")
#' 
#' M <- doMortalityModels(data = D, x, y, data.in = "dx", models = MM)
#' P <- doForecasts(M, h, level = 95, jumpchoice = "actual")
#' 
#' pex <- getForecasts(P, data.out = "ex")
#' @export
doForecasts <- function(object, h, level = 95, 
                        jumpchoice = c("actual", "fit"), 
                        verbose = TRUE, ...) {
  jumpchoice <- match.arg(jumpchoice)
  input <- as.list(environment())
  call  <- match.call()
  x     <- object$x
  y     <- max(object$y) + 1:h
  Mn    <- object$input$models # Model names
  
  for (i in 1:length(Mn)) {
    cat(Mn[i], " ")
    M <- with(object, get(Mn[i]))
    
    if (Mn[i] %in% c("LC", "PLAT", "HyndmanUllah", "LeeCarter")) {
      P <- forecast(M, h = h, jumpchoice = jumpchoice, level = level)
    } else {
      P <- predict(M, h = h, jumpchoice = jumpchoice, level = level)
    }
    assign(Mn[i], P)
  }
  
  remove(object, h, level, jumpchoice, M, Mn, P, i)
  out <- as.list(environment())
  out <- structure(class = "doForecasts", out)
  return(out)
}

