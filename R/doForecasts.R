

#' Perform Multiple Forecast of Mortality Using Various Models
#' 
#' @param object An object of class \code{MotalityModels} generated by the
#' \code{\link{doMortalityModels}} function.
#' @param h Number of years to be forecast in the future.
#' @param level Significance level of the confidence interval. Default: 95.
#' @param jumpchoice Method used for computation of jumpchoice. 
#'  Possibilities: \code{"actual"} (use actual rates from final year) 
#'  and \code{"fit"} (use fitted rates).
#' @inheritParams doMortalityModels
#' @examples 
#' x  <- 0:100
#' y  <- 1985:1999
#' h  <- 17
#' D  <- MortalityForecast.data$dx[paste(x), paste(y)]
#' MM <- c("MRWD", "LC", "FDM", "CoDa", "MEM6")
#' 
#' M <- doMortalityModels(data = D, x, y, data.in = "dx", models = MM)
#' P <- doForecasts(M, h, level = 95, jumpchoice = "actual")
#' 
#' pex <- getForecasts(P, data.out = "ex")
#' @export
doForecasts <- function(object, h, level = 95, 
                        jumpchoice = c("actual", "fit"), 
                        verbose = TRUE, ...) {
  jumpchoice <- match.arg(jumpchoice)
  input <- as.list(environment())
  call  <- match.call()
  x     <- object$x
  y     <- max(object$y) + 1:h
  Mn    <- object$input$models # Model names
  
  for (i in 1:length(Mn)) {
    cat(Mn[i], " ")
    M <- with(object, get(Mn[i]))
    
    if (Mn[i] %in% c("LC", "PLAT", "FDM")) {
      P <- forecast(M, h = h, jumpchoice = jumpchoice, level = level)
    } else {
      P <- predict(M, h = h, jumpchoice = jumpchoice, level = level)
    }
    assign(Mn[i], P)
  }
  
  remove(object, h, level, jumpchoice, M, Mn, P, i)
  out <- as.list(environment())
  out <- structure(class = "doForecasts", out)
  return(out)
}


#' Get Predicted Values
#' @param object An object of class \code{doForecasts}.
#' @inheritParams getAccuracy
#' @export
getForecasts <- function(object, 
                         data.out = c("qx", "mx", "dx", "lx", "Lx", "Tx", "ex"),
                         ...) {
  data.out <- match.arg(data.out)
  Mn   <- object$input$object$input$models # Model names
  x    <- object$x
  
  DX <- list()
  for (i in 1:length(Mn)) {
    M <- with(object, get(Mn[i]))
    
    if (Mn[i] %in% c("LC", "PLAT")) {
      mx <- M$rates
      dx <- convertFx(x, mx, from = "mx", to = "dx", lx0 = 1, ...)
      
    } else if (Mn[i] %in% c("FDM")) {
      mx <- M$rate$mean
      dx <- convertFx(x, mx, from = "mx", to = "dx", lx0 = 1, ...)
      
    } else if (Mn[i] %in% c("MRW", "MRWD")) {
      mx <- exp(M$predicted.values)
      dx <- convertFx(x, mx, from = "mx", to = "dx", lx0 = 1, ...)
      
    } else {
      dx <- M$predicted.values
    }
    DX[[i]] <- dx
  }
  
  fn  <- function(Z) convertFx(x, Z, from = "dx", to = data.out, lx0 = 1)
  out <- lapply(DX, fn)
  names(out) <- Mn
  out <- structure(class = "getForecasts", out)
  return(out)
}
